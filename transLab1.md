在实验室0中，你使用互联网流套接字从一个网站获取信息并发送电子邮件。发送电子邮件，使用Linux内置的传输控制协议（TCP）的实现。协议（TCP）的内置实现。这个TCP实现设法产生了一对可靠的按顺序的 字节流（一个从你到服务器，一个从相反方向），尽管 底层网络只提供 "尽力而为 "的数据报。我们的意思是：短的 的数据包，这些数据包可能会丢失、重新排序、改变或重复。你也实现了 字节流抽象，在一台计算机的内存中。在接下来的四周里，你将实现TCP。你将实现TCP，在一对计算机之间提供字节流抽象。分隔在一个不可靠的数据报网络中。


我为什么要这样做？在一个不同的、不太可靠的服务之上提供一个服务或一个抽象。在不同的、不太可靠的服务之上提供服务或抽象，这就是网络中许多有趣的问题。在过去的40年里，研究人员和从业人员已经想出了如何传达各种 的东西--信息和电子邮件、超链接文件、搜索引擎、声音和视频、虚拟世界、协作性的 视频、虚拟世界、协作式文件共享、数字货币--在互联网上。TCP本身的作用，即使用不可靠的数据报提供一对可靠的字节流，是这方面的典型例子。这方面的典型例子之一。一个合理的观点是，TCP的实现 是地球上使用最广泛的非微不足道的计算机程序。

实验作业将要求你以模块化的方式建立一个TCP实现。还记得你刚刚在实验室0中实现的ByteStream吗？在接下来的四个实验中，你将在网络上传递两个字节流。一个是 "出站 "字节流，用于本地应用程序写入套接字的数据，你的TCP将把这些数据发送给对等体；另一个是 "入站 "字节流，用于来自对等体的数据，将由本地应用程序读取。图1显示了这些部分是如何组合的。


1. 在实验1中，你将实现一个流重组器--一个将字节流的小片段（称为子串，或片段）按正确顺序缝合成连续的字节流的模块。

2. 在实验室2中，你将实现TCP中处理入站字节流的部分：TCPReceiver。TCPReceiver。这包括考虑TCP如何表示每个字节在数据流中的位置 在数据流中的位置，也就是所谓的 "序列号"。TCPReceiver负责 (a) 告诉发送方，它能够成功组装多少入站的字节流？这被称为 "确认"）和（b）发送方现在允许再发送多少字节（"流量控制"）。

3. 在实验3中，你将实现TCP中处理出站字节流的部分：TCPSender。当发送方怀疑它传输的一个段在途中丢失了，并且没有到达接收方时，它应该如何反应？它应该在什么时候再次尝试并重新传输一个丢失的段？

4. 在实验室4中，你将结合前几个实验室的工作，创建一个工作的 TCP实现：一个TCPConnection，其中包含一个TCPSender和TCPReceiver。你将用它来与世界各地的真实服务器对话。

1. 请确保你已经将所有的解决方案提交给实验室0。

请不要修改 libsponge 目录顶层以外的任何文件，或 webget.cc。否则，你在合并 Lab 1 的启动代码时可能会遇到麻烦。

2.在实验作业的资源库中，运行git fetch来检索实验作业的最新版本。最新版本的实验作业。

3. Download the starter code for Lab 1 by running git merge origin/lab1-startercode .

4. Within your build directory, compile the source code: make (you can run, e.g.,
make -j4 to use four processors when compiling).


5. Outside the build directory, open and start editing the writeups/lab1.md file. This
is the template for your lab writeup and will be included in your submission.


三. 将子字符串按顺序排列
    在本实验和下一个实验中，你将实现一个TCP接收器：接收数据报并将其转化为可靠的字节流的模块，以便由应用程序从套接字中读取--就像你的webget程序在实验0中从webserver中读取字节流。
    